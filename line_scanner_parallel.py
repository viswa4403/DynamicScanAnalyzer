from random import randint
import threading
import time

# Constants
WEIGHTS = [
    0.00025177,
    0.008666992,
    0.078025818,
    0.24130249,
    0.343757629,
    0.24130249,
    0.078025818,
    0.008666992,
    0.000125885,
]  # Filter weights for a weighted sum calculation
THRESHOLD = 40  # Threshold value for the filter function to determine output

class Input:
    """
    This class handles input generation from a file or randomly generated values.
    If a file is provided, it reads input values from the file. Otherwise, it generates random pairs of integers.
    """
    def __init__(self, fileName=None, M=12, N=10):
        self.fileName = fileName
        self.f = None
        self.currentLine = []
        self.numberOfRows = 0
        self.N = float("inf")
        self.M = float("inf")

        # If a file name is provided, open the file and read the first line
        if fileName is not None:
            self.f = open(fileName, "r")
            self.currentLine = self.f.readline().split(",")
            if len(self.currentLine[0]) == 0:  # Check for end of file
                self.close()
                raise Exception("End of file reached.")
            self.currentLine = [int(x) for x in self.currentLine]  # Convert line values to integers
            self.M = len(self.currentLine)  # Set the number of columns (M) to the length of the line
            return

        # If no file, set M and N to user-defined values
        self.M = M
        self.N = N

    def generate(self, seen):
        """
        Generates a pair of input values.
        If reading from a file, retrieves values from the current line.
        Otherwise, generates random values.
        """
        if self.numberOfRows >= self.N:
            raise Exception("Number of rows exceeded.")

        if seen >= self.M - 4:
            return [0, 0]  # Return zeros if the buffer is almost full

        if self.f is not None:
            if len(self.currentLine) == 0:  # Read a new line if the current line is empty
                self.currentLine = self.f.readline().split(",")
                if len(self.currentLine[0]) == 0:  # End of file
                    self.close()
                    raise Exception("End of file reached.")
                self.currentLine = [int(x) for x in self.currentLine]

            [x, y] = [int(self.currentLine[0]), int(self.currentLine[1])]  # Extract the next pair
            self.currentLine = self.currentLine[2:]  # Remove the processed pair from the current line
            return [x, y]

        # Generate random pair if not using a file
        return [randint(0, 255), randint(0, 255)]

    def close(self):
        """Closes the file if it was opened."""
        if self.f is not None:
            self.f.close()

def filter(buffer):
    """
    Applies a weighted sum filter to the buffer using the predefined WEIGHTS.
    Returns 1 if the sum exceeds the THRESHOLD, otherwise returns 0.
    """
    sum = 0
    for i in range(len(WEIGHTS)):
        sum += buffer[i] * WEIGHTS[i]

    buffer.pop(0)  # Remove the oldest element from the buffer

    # Return 1 if the weighted sum is greater than the threshold, otherwise 0
    if sum > THRESHOLD:
        return 1
    return 0

def applyFilter(buffer, filtered):
    """
    Applies the filter function twice and appends the results to the filtered list.
    """
    filtered.append(filter(buffer))
    filtered.append(filter(buffer))

def updateBuffer(buffer, input, seen):
    """
    Extends the buffer with new input values generated by the Input class.
    """
    buffer.extend(input.generate(seen))

# Main execution
input = Input("input.csv")  # Initialize the Input class with a file
try:
    while True:
        start = time.time_ns()  # Record the start time for performance measurement
        input.numberOfRows += 1
        buffer = [0, 0, 0, 0]  # Initialize the buffer with four zeros
        seen = 0

        # Generate three pairs of input values by default and add them to the buffer
        for i in range(3):
            buffer.extend(input.generate(seen))
            seen += 2

        filtered = []  # List to store filtered results
        while len(filtered) < input.M:  # Continue until filtered results reach the number of columns
            # Create threads for applying the filter and updating the buffer
            t1 = threading.Thread(target=applyFilter, args=(buffer, filtered))
            t2 = threading.Thread(target=updateBuffer, args=(buffer, input, len(filtered) + 2))
            t1.start()
            t2.start()
            t1.join()
            t2.join()

        # Output the time taken and the filtered results
        print("Time taken: ", time.time_ns() - start)
        print(filtered)
        print()
except Exception as e:
    # Handle end-of-file or other exceptions gracefully
    print("Rows processed: ", input.numberOfRows - 1)
    print("Exception: ", e)
